---
title: "knapsack: A package to solve the knapsack problem."
author: "Laura JuliÃ  Melis and Martin Svensson"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{knapsack: A package to solve the knapsack problem.}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

## 1. Introduction.

The knapsack problem is a discrete optimization problem where we have a knapsack that can take a limited weight $W$ and we want to fill this knapsack with a number of items $i = 1,...,n$, each with a weight $w_i$ and a value $v_i$. The goal is to find the knapsack with the largest value of the elements added to the knapsack.

This package contains three different functions that are three different approaches (of different complexity) to solve the problem raised above. These three functions have the same structure: 

**Inputs**

  - **x:** an object of class data.frame with two variables v (values) and w (weights).
  - **w:** numeric scalar object that represents the knapsack size.

**Output**

The functions return a list with two elements: the elements added to the knapsack and the maximum knapsack value.

### Instalation.
The first thing to do to be able to acces the functions is to install and load the package.
```{r, message=FALSE, warning=FALSE}
# You may need to install and load this package first: install.packages("devtools")
library(devtools)

# devtools::install_github("laurajuliamelis/Lab6",subdir="knapsack")
library(knapsack)
```

```{r include=FALSE}
# We need this package to measure the time that it takes to evaluate the functions.
#install.packages("microbenchmark")
library(microbenchmark)

# We need this package for the profiling.
# install.packages("profvis")
library(profvis)
```


## 2. Functions.  

### 2.0. Example data. 

The data used as an example to show how the functions work in the following sections is generated as showed below.

```{r}
set.seed(42)
n <- 2000
knapsack_objects <- data.frame( w=sample(1:4000, size = n, replace = TRUE),
                                v=runif(n = n, 0, 10000))
```

### 2.1. brute_force_knapsack( ).

This function uses the brute force search algorithm. This algorithms works by going through all possible alternatives (all possible combinations $2^n$ are evaluated) and return the maximum value found.

**Example**
```{r}
brute_force_knapsack(x = knapsack_objects[1:8,], W = 3500)
```

**QUESTION: How much time does it takes to run the algorithm for n = 16 objects?**

We will use the function `microbenchmark` to measure the time that it takes to evaluate this function:
```{r}
#microbenchmark(brute_force_knapsack(x = knapsack_objects[1:16,], W = 3500), times = 5)
```


### 2.2. knapsack_dynamic( ). 

This function uses the dynamic programming algorithm. This algorithm works by iterating over all possible values of w (see *References* for more information).

**Example**
```{r}
knapsack_dynamic(x = knapsack_objects[1:8,], W = 3500)
```

**QUESTION: How much time does it takes to run the algorithm for n = 500 objects?**
```{r}
#microbenchmark(knapsack_dynamic(x = knapsack_objects[1:500,], W = 3500), times = 5)
```

### 2.3. greedy_knapsack( ).

This function uses the greedy approximation algorithm. This algorithm works by: (i) Computing the value-to-weight ratios, (ii) sorting the items in decreasing order of the value-to-weight ratios and (iii) placing the sorted items in the knapsack until the current weight is higher than the knapsack capacity W.

**Example**
```{r}
greedy_knapsack(x = knapsack_objects[1:8,], W = 3500)
```

**QUESTION: How much time does it takes to run the algorithm for n = 1000000 objects?**
```{r}
set.seed(42)
n <- 1000000
knapsack_objects <- data.frame( w=sample(1:4000, size = n, replace = TRUE),
                                v=runif(n = n, 0, 10000))

#microbenchmark(greedy_knapsack(x = knapsack_objects[1:1000000,], W = 3500), times = 5)
```

## 3. Profiling and optimization.
**NOTE:** Package `lineprof` is not available for R version 3.6.1, so we will use package `profvis` instead.

### 3.1.  Brute force search algorithm.
```{r}
#profvis(brute_force_knapsack(x = knapsack_objects[1:16,], W = 3500))
```

### 3.2. Dynamic programming algorithm.
```{r}
#profvis(knapsack_dynamic(x = knapsack_objects[1:500,], W = 3500))
```

### 3.3. Greddy approximation algorithm.
```{r}
#profvis(greedy_knapsack(x = knapsack_objects[1:1000000,], W = 3500))
```

**QUESTION: What performance gain could you get by trying to improving your code?**

After analyzing the `profvis` outputs we consider that, regarding the `brute_force_knapsack()` and the `greedy_knapsack()` functions, they are fast enough given the large amount of data they are evaluating. 

Concerning the `knapsack_dynamic()` function, we can see how there are some lines of code that are a bit time consuming.

So maybe we could get a performance gain in this algorithm by using Rcpp and C++, but the gain would be really small.


## 4. Implentation in `Rcpp`.

**QUESTION: What performance gain could you get by using Rcpp and C++?**

## 5. Parallelization of brute force search.

**QUESTION: What performance gain could you get by parallelizing brute force search?**

  -**If n=16.**
  
Process time with `parallel=FALSE` (by default):
```{r}
#microbenchmark(brute_force_knapsack(x = knapsack_objects[1:16,], W = 3500), times = 5)
```

Process time with `parallel=TRUE` :
```{r}
#microbenchmark(brute_force_knapsack(x = knapsack_objects[1:16,], W = 3500, parallel = TRUE), times = 5)
```

  -**If n=20.**
  
Process time with `parallel=FALSE` (by default):
```{r}
#microbenchmark(brute_force_knapsack(x = knapsack_objects[1:20,], W = 3500), times = 1)
```

Process time with `parallel=TRUE` :
```{r}
#microbenchmark(brute_force_knapsack(x = knapsack_objects[1:20,], W = 3500, parallel = TRUE), times = 1)
```

We observe how the mean process time difference increases between the parallel and the serial programming as the n increases as well. 

## References.
* Brute force algorithm: <https://en.wikipedia.org/wiki/Knapsack_problem>
* Dynamic problem algorithm: <https://en.wikipedia.org/wiki/Knapsack_problem#0.2F1_knapsack_problem>
* Greedy approximation algorithm: <https://en.wikipedia.org/wiki/Knapsack_problem#Greedy_approximation_algorithm>